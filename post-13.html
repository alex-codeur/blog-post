<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/bootstrap.css">
    <link rel="stylesheet" href="css/style.css">
    <title>Blog</title>
</head>

<body>
    <div class="container">
        <h1>Node JS API: Construire une API REST avec Node JS et Express</h1>

        <h4>Table des mati√®res</h4>

        <ul>
            <li>Pourquoi utiliser Node JS pour construire une API REST ?
            </li>
            <li>Construire l'API Node Express</li>
            <li>Cr√©er un serveur Express</li>
            <li>D√©finir une ressource et ses routes</li>
            <li>A votre tour de jouer !</li>
            <li>Acc√©der au code source de cet anti-tuto</li>
            <li>Passer √† l'√©tape suivante</li>
            <li>Aller plus loin</li>
        </ul>

        <p>Depuis plusieurs ann√©es, NodeJS, souvent accompagn√© de son framework Express, s'est fait une place dans le
            monde du d√©veloppement web. Dans le m√™me temps, le standard d'API REST s'est impos√© comme r√©f√©rence pour les
            √©changes de donn√©es entre serveurs et clients. La stack Node JS API REST est devenue un choix pertinent dans
            la conception de web services.</p>

        <p>Ceci n'est pas un tutoriel mais un guide pour vous aider √† comprendre comment construire une API REST.
            Retrouvez l'ensemble de nos guides Node JS.</p>

        <h3>Pourquoi utiliser Node JS pour construire une API REST ?</h3>

        <p>Pour la construction d'une API Node JS est un choix qui est souvent pertinent pour les raisons suivantes:</p>

        <ol>
            <li>
                <h5>Son traitement non bloquant des requ√™tes.</h5>
                NodeJS ne dispose que d'un seul thread. C‚Äôest-√†-dire qu'il n'y a qu'un seul "moteur" disponible pour
                traiter les requ√™tes entrantes au serveur. Toutefois Node JS a la capacit√© de sous-traiter les fonctions
                "bloquantes" √† la callback queue, permettant de revenir traiter les autres requ√™tes entrantes tr√®s
                rapidement.
            </li>
            <li>
                <h5>Sa performance et sa scalabilit√©</h5>
                Node JS √©tant capable de traiter plusieurs requ√™tes de mani√®re non bloquantes, coupl√© √† sa modularit√©,
                sa performance dans le cadre d'une API est remarquable. La conception d'une Node JS API permet de
                multiplier les instances des modules qui sont sous pression des appels entrants.
            </li>
            <li>
                <h5>L'√©cosyst√®me JavaScript et les packages open source disponibles</h5>
                NPM est la registry (qu'on pourrait traduire comme biblioth√®que) qui h√©berge l'ensemble des librairies.
                Quel que soit votre besoin, il y a surement une librairie pour vous aider √† coder votre fonctionnalit√©.
                Cette richesse de l'√©cosyst√®me rend le d√©veloppement d'une API Node JS plus rapide.
            </li>
        </ol>

        <h3>Construire l'API Node Express</h3>

        <p>Dans ce guide, nous allons cr√©er ensemble une API REST tr√®s simple pour que vous puissiez comprendre chaque
            √©l√©ment qui la constitue. Nous n'allons pas faire de tests et sauter quelques bonnes pratiques qui ne sont
            pas dans le scope de ce guide.</p>

        <h4>Cr√©er un serveur Express</h4>

        <p>Votre Node JS API est avant tout un serveur web √† l'√©coute des requ√™tes HTTP entrantes. Pour d√©marrer ce
            serveur web, nous allons utiliser le framework Express.</p>

        <h5>D√©marrage du projet Node JS API</h5>

        <ol>
            <li>Cr√©ez votre r√©pertoire de votre future API et naviguez √† l'int√©rieur</li>
            <li>Saisissez la commande npm init et r√©pondez aux questions</li>
            <li>Cr√©er un fichier index.js</li>
        </ol>

        <p>Vous aurez maintenant dans votre r√©pertoire un fichier package.json, qui va reprendre diff√©rentes
            informations du projet et qui contiendra les d√©pendances qu'on va y installer.</p>

        <h4>Ajout d'Express √† notre Node JS API</h4>

        <p>Retournez maintenant √† votre terminal et tapez la commande suivante:</p>

        <div class="jumbotron">
            npm install express
        </div>

        <p>Cette commande a pour but de t√©l√©charger depuis la registry NPM puis d'installer la librairie express ainsi
            que l'ensemble des librairies dont express a besoin pour fonctionner dans votre r√©pertoire de travail, dans
            le r√©pertoire node_modules. NPM va √©galement l'ajouter dans votre package.json dans l'objet dependencies.
        </p>

        <div class="jumbotron">
            ‚ÑπÔ∏è Dans certains tutos en ligne, vous pourrez trouver l'option --save ou -s apr√®s la commande npm install.
            Sachez qu'avant la version 5.0 de NPM, il fallait passer cette option pour retrouver la d√©pendance ajout√©e
            dans le package.json. Depuis la version 5.0, d√®s que vous passez la commande npm install, la librairie est
            par d√©faut ajout√©e au package.json. Il n'est plus n√©c√©ssaire de passer l'option-s ou --save
        </div>

        <div class="jumbotron">
            ‚ùì <h5>Pourquoi est-ce qu'on a besoin d'ajouter la d√©pendance dans package.json ?</h5>
            ‚ÑπÔ∏è Pour qu'un projet d'API Node JS ou tout autre projet Node puisse √™tre repris par un autre d√©veloppeur ou
            √™tre d√©ploy√© sur un serveur √† distance, le package.jsonDOIT r√©f√©rencer toutes les librairies dont
            l'application a besoin pour bien fonctionner. Vous n'uploaderez pas toutes votre application avec le
            r√©pertoire node_modules mais simplement votre code et le package.json. Le serveur sera en charge de faire un
            npm install pour r√©cup√©rer toutes les d√©pendances.
        </div>

        <h4>Cr√©ation du serveur Express dans notre fichier index.js</h4>

        <p>Maintenant qu'Express est disponible dans notre projet, nous pouvons cr√©er le serveur. Commen√ßons par
            int√©grer la librairie express dans notre fichier index.js:</p>

        <div class="jumbotron">
            <p>const express = require('express')</p>
            <p>const app = express()</p>
        </div>

        <p>Le require('express') est une fa√ßon d'importer la librairie express et ses fonctions dans notre code. La
            constante app est l'instanciation d'un objet Express, qui va contenir notre serveur ainsi que les m√©thodes
            dont nous aurons besoin pour le faire fonctionner.</p>

        <div class="jumbotron">
            <h5>‚ùì Vous avez peut-√™tre vu la syntaxe import express from 'express' ? </h5>Cette syntaxe d'import bas√©e
            sur ES6. Cette syntaxe est tr√®s utilis√©e dans le d√©veloppement frontend car elle permet de n'importer que
            les m√©thodes qui sont utilis√©es et de r√©duire la taille du fichier JavaScript √† charger par le navigateur.
            Dans le cas d'une Node JS API, le code est ex√©cut√© sur un serveur. Le gain n'est pas aussi important qu'en
            frontend et passer sur une syntaxe d'import va demander plus de travail de configuration qu'une syntaxe
            utilisant require
        </div>

        <p>Pour le moment, votre serveur est pr√©par√© mais pas encore lanc√©. Si vous vous rendez sur localhost:8080
            depuis votre navigateur, vous devriez avoir une erreur.</p>

        <p>Pour que notre serveur puisse √™tre √† l'√©coute il faut maintenant utiliser la m√©thode listen fournie dans app
            et lui sp√©cifier un port. Le plus souvent en d√©veloppement nous utilisons 8080, 3000 ou 8000. √áa n'a pas
            d'importance tant que vous n'avez pas d'autres applications qui tournent localement sur ce m√™me port.</p>

        <div class="jumbotron">
            <p>app.listen(8080, () => {</p>
            <p>console.log('Serveur √† l'√©coute')</p>
            <p>})</p>
        </div>

        <p>En lan√ßant la commande node index.js dans votre terminal, vous verrez qu'il affichera que votre serveur est √†
            l'√©coute. Cela veut dire que tout fonctionne bien. S'il y a une erreur, vous aurez droit √† un message
            d'erreur sur votre terminal.</p>

        <p>Si vous vous rendez sur votre navigateur √† l'adresse localhost:8080 (ou l'autre port que vous aurez choisi),
            votre serveur r√©pond √† votre navigateur. N'ayant pour l'instant aucune route de configur√©e, il vous retourne
            cette erreur Cannot GET / mais il est bel et bien fonctionnel.</p>

        <h4>D√©finir une ressource et ses routes</h4>

        <p>Maintenant que votre serveur est fonctionnel, il est temps de d√©finir le coeur de votre API: ses ressources.
        </p>

        <h5>D√©finition des ressources de notre Node JS API</h5>

        <p>Pour notre exemple, nous prendrons le cas d'une soci√©t√© exploitant des parkings de longue dur√©e et qui prend
            des r√©servations de la part de ses clients. Nous aurons besoin des fonctionnalit√©s suivantes:</p>

        <ul>
            <li>Cr√©er un parking</li>
            <li>Lister l'ensemble des parkings</li>
            <li>R√©cup√©rer les d√©tails d'un parking en particulier</li>
            <li>Supprimer un parking</li>
            <li>Prendre une r√©servation d'une place dans un parking</li>
            <li>Lister l'ensemble des r√©servations</li>
            <li>Afficher les d√©tails d'une r√©servation en particulier</li>
            <li>Supprimer une r√©servation</li>
        </ul>

        <p>Ces op√©rations sont plus commun√©ment appel√©es CRUD, pour CREATE, READ, UPDATE, DESTROY. Dans notre exemple,
            notre Node JS API dispose de deux ressources: le Parking et la R√©servation.</p>

        <h5>Cr√©ation des routes</h5>

        <p>Le standard d'API REST impose que nos routes soient centr√©es autour de nos ressources et que la m√©thode HTTP
            utilis√©e refl√®te l'intention de l'action. Dans notre cas nous aurons besoin des routes suivantes:</p>

        <ul>
            <li>GET /parkings</li>
            <li>GET /parkings/:id</li>
            <li>POST /parkings</li>
            <li>PUT /parkings/:id</li>
            <li>DELETE /parkings/:id</li>
        </ul>

        <p>Les r√©servations √©tant une sous-ressource de la ressource parking, nous aurons √† cr√©er les routes suivantes:
        </p>

        <ul>
            <li>GET /parkings/:id/reservations</li>
            <li>GET /parking/:id/reservations/:idReservation</li>
            <li>POST /parkings/:id/reservations</li>
            <li>PUT /parking/:id/reservations/:idReservation</li>
            <li>DELETE /parking/:id/reservations/:idReservation</li>
        </ul>

        <p>Pour que notre Node JS API fonctionne, nous avons besoin de donn√©es √©chantillon.</p>

        <p>Le but de ce guide est de vous aider √† comprendre le bon fonctionnement d'une API. Nous n'allons pas
            connecter de vraie base de donn√©es dans ce guide. Nous allons √† la place utiliser un fichier JSON contenant
            un √©chantillon de donn√©es pour manipuler notre API.
            Pour t√©l√©charger ce fichier, cliquez ici puis placez-le √† la racine de votre r√©pertoire de travail.</p>

        <p>Commen√ßons par d√©finir la route GET /parkings.</p>

        <p>Cette route a pour but de r√©cup√©rer l'ensemble des parkings dans nos donn√©es. Allons modifier notre fichier
            index.js:</p>

        <div class="jumbotron">
            <p>const express = require('express')</p>
            <p>const app = express()</p>
            <p>app.get('/parkings', (req,res) => {</p>
            <p>res.send("Liste des parkings")</p>
            <p>})</p>
            <p>app.get('/parkings', (req,res) => {</p>
            <p> res.send("Liste des parkings")</p>
            <p>})</p>
            <p>app.listen(8080, () => {</p>
            <p>console.log("Serveur √† l'√©coute")</p>
            <p>})</p>
        </div>

        <p>la m√©thode .get d'express permet de d√©finir une route GET. Elle prend en premier param√®tre une String qui
            d√©fini la route √† √©couter et une callback, qui est la fonction √† ex√©cuter si cette route est appel√©e. Cette
            callback prend en param√®tre l'objet req, qui reprend toutes les donn√©es fournies par la requ√™te, et l'objet
            res, fourni par express, qui contient les m√©thodes pour r√©pondre √† la requ√™te qui vient d'arriver.</p>

        <p>Dans ce code, √† l'arriv√©e d'une requ√™te GET sur l'URL localhost:8080/parkings, le serveur a pour instruction
            d'envoyer la String "Liste des parkings".</p>

        <p>Coupez votre serveur node s'il tourne encore (avec la commande ctrl+c dans le terminal) et relancez la
            commande node index.js pour prendre en compte les modifications.</p>

        <div class="jumbotron">
            ‚ÑπÔ∏è Pour chaque changement dans le code de votre Node JS API, il faudra relancer le serveur afin qu'ils
            soient pris en compte. Il existe la librairie Nodemon qui permet de relancer automatiquement votre serveur
            node √† chaque fois que vous sauvegardez votre fichier. Pour l'installer, saisissez la commande npm install
            nodemon -g puis lorsque vous lancerez pour la premi√®re fois votre serveur, utilisez la commande nodemon au
            lieu de node index.js
        </div>

        <p>Maintenant que notre route fonctionne et est capable de recevoir la requ√™te entrante, nous allons pouvoir
            renvoyer la donn√©e des parkings au lieu d'avoir simplement une cha√Æne de caract√®res:</p>

        <div class="jumbotron">
            <p>const express = require('express')</p>
            <p>const app = express()</p>
            <p>const parkings = require('./parkings.json')</p>
            <p>app.get('/parkings', (req,res) => {</p>
            <p>res.status(200).json(parkings)</p>
            <p>})</p>
            <p>app.listen(8080, () => {</p>
            <p>console.log("Serveur √† l'√©coute")</p>
            <p>})</p>
        </div>

        <p>Nous avons remplac√© la m√©thode send par la m√©thode json. En effet notre API REST va retourner un fichier JSON
            au client et non pas du texte ou un fichier html. Nous avons √©galement ajout√© le statut 200, qui correspond
            au code r√©ponse http indiquant au client que sa requ√™te s'est termin√©e avec succ√®s.</p>
    </div>

    <p>Notre route GET /Parkings est maintenant termin√©e. Il faut maintenant mettre en place les routes suivantes en
        utilisant les m√©thodes JavaScript pour r√©pondre √† nos besoins.</p>

    <p>La route GET /parkings/:id est la suivante. Nous avons besoin de r√©cup√©rer l'id de la route depuis l'URL pour
        n'afficher que le JSON de ce parking dans la r√©ponse. Cet id se trouve dans les params, dans l'objet req, envoy√©
        par le navigateur.</p>

    <p>Reprenons notre fichier index.js:</p>

    <div class="jumbotron">
        <p>const express = require('express')</p>
        <p>const app = express()</p>
        <p>const parkings = require('./parkings.json')</p>
        <p>app.get('/parkings', (req,res) => {</p>
        <p>res.status(200).json(parkings)</p>
        <p>})</p>
        <p>app.get('/parkings/:id', (req,res) => {</p>
        <p>const id = parseInt(req.params.id)</p>
        <p>const parking = parkings.find(parking => parking.id === id)</p>
        <p>res.status(200).json(parking)</p>
        <p>})</p>
        <p>app.listen(8080, () => {</p>
        <p>console.log("Serveur √† l'√©coute")</p>
        <p>})</p>
    </div>

    <p>Nous r√©cup√©rons l'id demand√© par le client dans les params de la requ√™te. Comme ma route a d√©fini '/:id', la
        valeur pass√©e dans le param sera sous forme d'objet contenant la cl√© "id". La valeur de req.params.id contient
        ce qui est envoy√© dans l'URL, sous forme de String. Comme l'id de chaque parking est sous forme de Number, il
        faut d'abord transformer le params de String en Number. Ensuite, il faut rechercher dans les parkings pour
        trouver celui qui a l'id correspondant √† celui pass√© dans l'URL.</p>

    <p>Passons √† la route POST /parkings pour pouvoir cr√©er un nouveau parking.</p>

    <p>Pour cr√©er un nouveau parking via votre Node JS API, il va falloir envoyer au serveur les donn√©es relatives √† ce
        nouvel √©l√©ment, telles que son nom, son type etc. D√®s qu'il s'agit d'envoyer de la donn√©e, il faut utiliser une
        requ√™te POST.</p>

    <div class="jumbotron">
        <p>‚ÑπÔ∏è Les requ√™tes HTTP contiennent toutes un header. Il s'agit de l'en-t√™te de la requ√™te fournissant un
            ensemble d'√©l√©ments, notamment ce qui est pass√© dans l'URL comme les params dans l'url, comme l'id ou les
            query params qui sont pass√© en fin d'URL apr√®s un "?".</p>
        <p>Certaines requ√™tes HTTP peuvent contenir un body, le corps de la requ√™te. Il est utilis√© pour envoyer de la
            donn√©e au serveur. On retrouve le body dans les requ√™tes POST, PUT et PATCH</p>

        <p>Pour r√©cup√©rer les donn√©es pass√©es dans la requ√™te POST, nous devons ajouter un middleware √† notre Node JS
            API afin qu'elle soit capable d'interpr√©ter le body de la requ√™te. Ce middleware va se placer √† entre
            l'arriv√©e de la requ√™te et nos routes et ex√©cuter son code, rendant possible l'acc√®s au body.</p>

        <p>Voici notre fichier index.js:</p>

        <div class="jumbotron">
            <p>const express = require('express')</p>
            <p>const app = express()</p>
            <p>const parkings = require('./parkings.json')</p>
            <p>// Middleware</p>
            <p>app.use(express.json())</p>
            <p>app.get('/parkings', (req,res) => {</p>
            <p>res.status(200).json(parkings)</p>
            <p>})</p>
            <p>app.get('/parkings/:id', (req,res) => {</p>
            <p>const id = parseInt(req.params.id)</p>
            <p>const parking = parkings.find(parking => parking.id === id)</p>
            <p>res.status(200).json(parking)</p>
            <p>})</p>
            <p>app.listen(8080, () => {</p>
            <p>console.log("Serveur √† l'√©coute")</p>
            <p>})</p>
        </div>

        <div class="jumbotron">
            <p>‚ÑπÔ∏è Il se peut que vous soyez tomb√©s sur plusieurs tutos qui utilisent le middleware body-parser. Il faut
                savoir qu'entre la version 4.0 et 4.16, les d√©veloppeurs d'express avaient retir√© le body parser
                d'express car toutes les applications n'en ont pas forc√©ment besoin. Pendant tout ce temps il √©tait
                n√©c√©ssaire d'ajouter la librairie body-parser.</p>

            <p>üí° Depuis la version 4.16, express a int√©gr√© nativement body parser, lui-m√™me b√¢ti sur la m√™me librairie.
                Vous pouvez donc utiliser express.json() et vous affranchir d'importer une nouvelle librairie d√©j√†
                pr√©sente dans Express.</p>
        </div>

        <p>Il n'y a plus qu'√† ajouter la route POST et √† tester notre nouvelle route:</p>

        <div class="jumbotron">
            <p>const express = require('express')</p>
            <p>const app = express()</p>
            <p>const parkings = require('./parkings.json')</p>
            <p>// Middleware</p>
            <p>app.use(express.json())</p>
            <p>app.get('/parkings', (req,res) => {</p>
            <p>res.status(200).json(parkings)</p>
            <p>})</p>
            <p>app.get('/parkings/:id', (req,res) => {</p>
            <p>const id = parseInt(req.params.id)</p>
            <p>const parking = parkings.find(parking => parking.id === id)</p>
            <p>res.status(200).json(parking)</p>
            <p>})</p>
            <p>app.post('/parkings', (req,res) => {</p>
            <p>parkings.push(req.body)</p>
            <p>app.listen(8080, () => {</p>
            <p> res.status(200).json(parkings)</p>
            <p>})</p>
            <p>console.log("Serveur √† l'√©coute")</p>
            <p>})</p>
        </div>

        <p>Pour tester notre route POST, nous allons utiliser l'outil Postman qui nous permet de manipuler facilement
            des API.</p>

        <p>Notre requ√™te POST sur l'URL localhost:8080/parkings contient dans son body un objet JSON contenant l'id, le
            nom, le type et la ville de notre nouveau parking.</p>

        <p>Dans un cas r√©el de Node JS API, votre base de donn√©es aurait g√©n√©r√© l'id. Dans notre cas nous allons le
            passer √† la main pour simplifier.</p>

        <p>Passons √† la route PUT /parkings/:id pour pouvoir modifier un parking.</p>

        <div class="jumbotron">
            <p>app.put('/parkings/:id', (req,res) => {</p>
            <p>const id = parseInt(req.params.id)</p>
            <p>let parking = parkings.find(parking => parking.id === id)</p>
            <p>parking.name =req.body.name,</p>
            <p>parking.city =req.body.city,</p>
            <p>parking.type =req.body.type,</p>
            <p>res.status(200).json(parking)</p>
            <p>})</p>
        </div>

        <p>Voici le code correspondant √† la route PUT. Je vous laisse deviner o√π le placer dans le fichier index.js</p>

        <div class="jumbotron">
            ‚ÑπÔ∏è Pour modifier un document dans une Node JS API, les m√©thodes PUT ou PATCH sont √† privil√©gier. Une requ√™te
            PUT va modifier l'int√©gralit√© du document par les valeurs du nouvel arrivant. Une requ√™te PATCH va
            uniquement mettre √† jour certains champs du document.
        </div>

        <p>Il reste maintenant √† terminer cette ressource avec la route DELETE /parkings</p>

        <div class="jumbotron">
            <p>app.delete('/parkings/:id', (req,res) => {</p>
            <p>const id = parseInt(req.params.id)</p>
            <p>let parking = parkings.find(parking => parking.id === id)</p>
            <p>parkings.splice(parkings.indexOf(parking),1)</p>
            <p>res.status(200).json(parkings)</p>
            <p>})</p>
        </div>

        <p>Votre Node JS API est maintenant capable de g√©rer la ressource Parking. Pour mettre en place la
            sous-ressource R√©servation, il faut r√©pliquer la logique.</p>

        <h4>A votre tour de jouer !
        </h4>

        <p>Pour pr√©parer les donn√©es de votre Node JS API, voici le fichier reservations.json √† placer √† la racine de
            votre projet.</p>

        <p>Pour la suite de la r√©alisation de votre Node JS API, c'est √† votre tour de jouer. Cette fois, les ressources
            R√©servation d√©pendent de la ressource Parking. Par exemple, la route GET /parkings/1/reservations va
            r√©cup√©rer l'ensemble des r√©servations du parking 1.</p>

        <div class="jumbotron">
            ‚ùó Dans la conception de cette Node JS API, nous avons fait le choix de faire de la ressource Reservation une
            sous ressource de Parking. Il n'y a pas la possibilit√© de r√©cup√©rer l'ensemble des r√©servations pour tous
            les parkings. C'est un choix de conception qui peut √™tre revu ult√©rieurement en cr√©ant une route
            /reservations
        </div>
    </div>
</body>

</html>