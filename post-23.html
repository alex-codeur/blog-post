<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/bootstrap.css">
    <link rel="stylesheet" href="css/style.css">
    <title>Blog</title>
</head>

<body>
    <div class="container">
        <h1>Architecture 3 tiers pour une API Node JS
        </h1>

        <h4>Table des mati√®res</h4>

        <ul>
            <li>Qu'est-ce que l'architecture 3 tiers ?
            </li>
            <li>Comment fonctionne l'architecture 3 tiers ?</li>
            <li>Les Models - la couche data</li>
            <li>Les Controllers et les Services - la couche applicative</li>
            <li>A vous d'impl√©menter votre architecture 3 tiers</li>
            <li>Etape 1 - S√©parer la connexion √† la base de donn√©es</li>
            <li>Etape 2 - Extraire la couche Data</li>
            <li>Etape 3 - S√©parer la couche logique</li>
            <li>Etape 4 - Extraire les routes dans un module d√©di√©</li>
            <li>Pour conclure</li>
        </ul>

        <p>Dans les articles pr√©c√©dents, nous avons vu comment cr√©er une Node JS API et comment y connecter une base de
            donn√©es MongoDB. Aujourd'hui, nous allons voir comment impl√©menter une architecture 3 tiers ou n-tiers √†
            notre API Node JS.</p>

        <p>Jusqu'√† maintenant, nous avons ajout√© le code de notre API dans un seul fichier. Aujourd'hui nous allons
            revoir l'architecture de notre API avant que le code source ne devienne un √©norme plat de spaghetti üçù.</p>

        <h3>Qu'est-ce que l'architecture 3 tiers ?</h3>

        <p>L'architecture 3 tiers est un pattern d'architecture de code source qui permet de s√©parer les diff√©rentes
            couches de l'application. √Ä l'instar du pattern MVC, l'architecture 3 tiers propose de s√©parer la couche
            donn√©es, la couche m√©tier et la couche interface utilisateur.</p>

        <div class="jumbotron">
            ‚ÑπÔ∏è Dans le cas d'une API, la couche d'interface est simplement le retour JSON et non pas des fichiers HTML.
        </div>

        <h3>Comment fonctionne l'architecture 3 tiers ?</h3>

        <p>Avant de r√©inventer la roue, je trouve pertinent d'observer comment les frameworks dominants du march√© ont
            fait leurs choix d'architecture. Le travail r√©alis√© est issu d'ann√©es d'exp√©rience de la part des
            contributeurs des projets open source et il serait dommage de se priver de ce savoir.</p>

        <p>Que ce soit NestJS, Adonis, Laravel ou Ruby on Rails, tous ces frameworks ont choisi une architecture MVC du
            fait qu'ils sont principalement utilis√©s pour cr√©er une application ou un site en Server Side Rendering.
            Lorsqu'on con√ßoit une API, nous n'avons pas de notions d'interface mais l'architecture va rester
            sensiblement la m√™me.</p>

        <h4>Les Models - la couche data</h4>

        <p>Dans l'architecture 3 tiers, comme en MVC, la couche donn√©e r√©side dans ses propres modules.</p>

        <p>Le but est de d√©coupler la logique m√©tier des op√©rations de base de donn√©es. Ainsi, vous pourrez faire
            √©voluer votre m√©tier et votre base de donn√©es s√©par√©ment. Par exemple, si vous devez faire √©voluer une
            fonctionnalit√© et que votre code m√©tier se refl√®te que par des requ√™tes SQL ou des requ√™tes Mongo, le
            travail du d√©veloppeur va √™tre beaucoup plus d√©licat et vous serez dans l'incapacit√© de faire des tests
            unitaires sur votre fonction.</p>

        <h4>Les Controllers et les Services - la couche applicative</h4>

        <p>Dans l'architecture 3 tiers, une seule brique repr√©sente la couche applicative. Or cette brique peut √™tre
            scind√©e en plusieurs niveaux. On parle l√† d'une architecture N Tiers.</p>

        <p>Dans une application tr√®s simple, mettre son code m√©tier dans le controller peut √™tre acceptable. En revanche
            d√®s que votre application se complexifie, il est consid√©r√© comme meilleur pratique de s√©parer votre logique
            m√©tier en Services ou Repositories et ne laisser au controller que les t√¢ches de validation, v√©rification de
            droits utilisateurs etc.</p>

        <h3>A vous d'impl√©menter votre architecture 3 tiers</h3>

        <p>√Ä toi de jouer ! Nous allons retravailler l'architecture de notre application en s√©parent plusieurs briques
            dans des modules s√©par√©s.</p>

        <h4>Etape 1 - S√©parer la connexion √† la base de donn√©es</h4>

        <p>Cette √©tape √©tant d√©licate, je vais te guider un peu plus que pour les autres.</p>

        <p>Jusqu'√† maintenant, votre serveur et votre base de donn√©es √©taient lanc√©s tous les deux depuis le fichier
            index.js. Ce qu'on va faire c'est s√©parer la connexion √† la base de donn√©es dans un autre fichier.</p>

        <p>Cr√©ez un fichier database.js √† la racine du projet:</p>

        <div class="jumbotron">
            const database = {}


            database.connect = async () => {
            /**
            * Import MongoClient & connexion √† la DB
            */
            const MongoClient = require('mongodb').MongoClient;
            const url = 'mongodb://localhost:27017';
            const dbName = 'parkingApi';
            let db
            MongoClient.connect(url, function(err, client) {
            console.log("Connected successfully to MongoDB Server");
            db = client.db(dbName);
            database.db = db
            });
            }

            module.exports = database
        </div>

        <p>Dans ce fichier, je commence par cr√©er un objet vide que je vais appeler database. Cet objet englobera une
            m√©thode que j'appelle connect et que je d√©clare juste apr√®s. Tu remarqueras que j'ai r√©cup√©r√© le code
            pr√©sent dans index.js.</p>

        <p>Dans la callback de la connexion, j'ai cr√©√© la cl√© db √† laquelle j'ai attribu√© la connexion √† la base de
            donn√©es 'parkingApi'.</p>

        <p>Dans le tuto pr√©c√©dent, j'utilisais l'objet db pour faire mes requ√™tes √† la base de donn√©es, par exemple:</p>

        <div class="jumbotron">
            db.collection('parkings').find({}).toArray()
        </div>

        <p>√âtant donn√© que je vais avoir besoin d'utiliser cet objet pour faire des requ√™tes dans d'autres fichiers que
            database.js, je l'ajoute √† l'objet database que je vais exporter.</p>

        <p>Ainsi je pourrais r√©utiliser ma connexion √† la base de donn√©es dans d'autres fichiers.</p>

        <p>Pour cr√©er cette connexion au lancement du serveur, je modifie le fichier index.js, j'importe le fichier
            database.js et je remplace tout le bloc contenant MongoClient par database.connectDB()</p>

        <div class="jumbotron">
            const database = require('./database')

            database.connect()
        </div>

        <h4>Etape 2 - Extraire la couche Data</h4>

        <p>Maintenant que nous avons pr√©parer notre app, nous pouvons mettre en place le d√©coupage en couches s√©par√©es
            en commen√ßant par la couche Data.</p>

        <p>Cr√©ez un r√©pertoire Model ainsi que les fichiers Parking.js et Reservation.js. Chacun de ces fichier va
            rassembler les op√©rations MongoDB.</p>

        <p>De la m√™me fa√ßon que nous avons proc√©d√© pour database.js, nous allons cr√©er un objet en d√©but de fichier qui
            contiendra l'ensemble des m√©thodes afin d'√™tre export√© comme module.</p>

        <p>Voici un exemple avec une requ√™te Mongo:</p>

        <div class="jumbotron">
            const connection = require('../database')
            const parking = {}

            parking.list = async function () {
            return await connection.db.collection('parkings').find({}).toArray()
            }

            module.exports = parking
        </div>

        <p>A votre tour de terminer le fichier en y ajoutant les autres m√©thodes de CRUD</p>

        <h4>Etape 3 - S√©parer la couche logique</h4>

        <p>La deuxi√®me √©tape de ce projet est de s√©parer la logique m√©tier de nos routes.</p>

        <p>Cr√©ez un r√©pertoire Controller dans lequel vous cr√©erez les fichiers parkingController.js et
            reservationController.js.</p>

        <p>Pour chaque controller, nous allons cr√©er les m√©thodes CRUD et faire appel aux m√©thodes que nous avons cr√©√©
            dans le module Model</p>

        <div class="jumbotron">
            const parking = require('../Model/parking')
            const parkingController = {}

            parkingController.getParkings = async (req,res)=> {
            try {
            const docs = await parking.list()
            res.status(200).json(docs)
            } catch (err) {
            console.log(err)
            throw err
            }
            }

            module.exports = parkingController
        </div>

        <p>On distingue maintenant deux couches, la couche Data dans le r√©pertoire Model et la couche applicative dans
            les controllers.</p>

        <p>Compl√©tez les fichiers pour retrouver l'ensemble des fonctionnalit√©s de parking et r√©servations.</p>

        <h4>Etape 4 - Extraire les routes dans un module d√©di√©
        </h4>

        <p>Jusque-l√† nous avons laiss√© nos routes les unes √† la suite des autres dans le fichier index.js. Bien que pour
            l'instant √ßa soit encore tenable, chaque ajout de fonctionnalit√© va agrandir ce fichier qui sert pour
            l'instant de fourre-tout.</p>

        <p>D'apr√®s la documentation d'express, nous pouvons extraire les routes dans leur propre module et les importer
            dans notre fichier index.js</p>

        <p>Donc on va passer d'un bloc de code qui fait tout:</p>

        <div class="jumbotron">
            app.get('/parkings', async (req,res) => {
            try {
            const docs = await db.collection('parkings').find({}).toArray()
            res.status(200).json(docs)
            } catch (err) {
            console.log(err)
            throw err
            }
            })
        </div>

        <p>ainsi que l'ensemble des autres routes √† :</p>

        <div class="jumbotron">
            app.get('/parkings', parkingController.getParkings)
        </div>

        <p>et index.js r√©duit √† une seule ligne:</p>

        <div class="jumbotron">
            app.use(routes.js)
        </div>

        <div class="jumbotron">
            ‚ÑπÔ∏è La m√©thode use() de l'instance d'Express permet d'impl√©menter un Middleware. Le Middleware est une
            m√©thode par laquelle la requ√™te HTTP va passer. Il peut soit l'intercepter pour en faire quelque chose de
            particulier, puis le passer au middleware suivant, soit l'intercepter pour traiter la requ√™te compl√®tement
            et renvoyer la r√©ponse.
        </div>

        <p>Cr√©ez un fichier routes.js √† la racine du projet puis d√©placez-y l'ensemble de nos routes. N'oubliez pas
            d'exporter le module routeur comme illustr√© sur la documentation.</p>

        <p>√Ä vous de jouer pour compl√©ter votre refactor</p>

        <h3>Pour conclure</h3>

        <p>Vous l'avez probablement remarqu√©, notre architecture 3 tiers est incompl√®te. Nous avons toujours la couche
            de pr√©sentation et la couche applicative qui sont encore tr√®s li√©es dans le controller.

        </p>

        <p>C'est un choix que j'ai d√©cid√© de garder pour ne pas ajouter de complexit√© pr√©matur√©e √† notre code. Dans les
            tutos suivant, nous allons ajouter de plus en plus de fonctionnalit√©s et √† ce moment-l√† nous s√©parerons la
            couche applicative dans des Services plut√¥t que de la laisser dans les Controllers</p>
    </div>
</body>

</html>